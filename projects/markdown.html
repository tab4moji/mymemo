<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown Viewer</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.8.1/github-markdown.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">

    <style>
        :root {
            --bg-color: #131314;
            --surface-color: #1E1F20;
            --header-bg: #2D2E30;
            --border-color: #444746;
            --text-main: #E3E3E3;
            --text-muted: #C4C7C5;
            --accent-color: #A8C7FA;
            --btn-hover: #3C4043;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Roboto', sans-serif;
            margin: 0;
        }

        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 900px;
            margin: 0 auto;
            padding: 45px;
            background-color: var(--bg-color);
            color: var(--text-main);
        }

        /* --- Code Block Container --- */
        .code-wrapper {
            margin-bottom: 16px;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            overflow: hidden;
            background-color: var(--surface-color);
        }

        /* --- Header --- */
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--header-bg);
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
            color: var(--text-muted);
            user-select: none;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 10px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .code-title {
            font-weight: 700;
            color: var(--text-main);
        }

        .code-lang {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            opacity: 0.8;
        }

        /* --- Copy Button --- */
        .copy-btn {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            border-radius: 6px;
            padding: 4px 10px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        .copy-btn:hover {
            background-color: var(--btn-hover);
            color: var(--text-main);
            border-color: var(--text-muted);
        }

        /* --- Pre / Code --- */
        .code-wrapper pre {
            margin: 0 !important;
            padding: 16px !important;
            background-color: var(--surface-color) !important;
            border: none !important;
            border-radius: 0 !important;
            overflow-x: auto;
        }

        .code-wrapper code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            background-color: transparent !important;
        }

        /* --- Snip Marker (省略行のスタイル) --- */
        .snip-line {
            display: block;
            margin: 8px 0;
            padding: 8px;
            background-color: rgba(168, 199, 250, 0.1); /* 薄い青 */
            color: var(--accent-color);
            text-align: center;
            font-style: italic;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            transition: background-color 0.2s;
            user-select: none;
        }
        .snip-line:hover {
            background-color: rgba(168, 199, 250, 0.2);
            text-decoration: underline;
        }

        @media (max-width: 767px) {
            .markdown-body { padding: 20px; }
        }
        #error-message {
            color: #ff897d; display: none; text-align: center; margin-top: 50px;
        }
    </style>
</head>
<body>
    <article id="content" class="markdown-body">
        <p style="text-align: center; color: #666; margin-top: 50px;">Loading...</p>
    </article>
    <div id="error-message"></div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/powershell.min.js"></script>

    <script>
        // 設定: 何行を超えたら省略するか
        const FOLD_THRESHOLD = 25;
        // 先頭・末尾の表示行数
        const SHOW_LINES = 10;

        async function loadMarkdown() {
            const params = new URLSearchParams(window.location.search);
            const filename = params.get('content') || 'README';
            const contentDiv = document.getElementById('content');

            try {
                const response = await fetch(`${filename}.md?t=${new Date().getTime()}`, { cache: "no-store" });
                if (!response.ok) throw new Error(`Failed to load ${filename}`);

                const markdownText = await response.text();
                const rawHtml = marked.parse(markdownText);
                const cleanHtml = DOMPurify.sanitize(rawHtml);
                
                contentDiv.innerHTML = cleanHtml;
                
                processCodeBlocks();
                document.title = filename;

            } catch (error) {
                console.error(error);
                contentDiv.style.display = 'none';
                document.getElementById('error-message').style.display = 'block';
                document.getElementById('error-message').textContent = `Error: ${error.message}`;
            }
        }

        function processCodeBlocks() {
            const pres = document.querySelectorAll('pre');

            pres.forEach(pre => {
                const code = pre.querySelector('code');
                if (!code) return;

                // 1. 言語とタイトルの解析 (class="language-python:app.py")
                let rawClass = code.className || '';
                let lang = 'text';
                let title = '';

                const match = rawClass.match(/language-([^\s"]+)/);
                if (match) {
                    const fullLang = match[1];
                    if (fullLang.includes(':')) {
                        const parts = fullLang.split(':');
                        lang = parts[0];
                        title = parts.slice(1).join(':');
                    } else {
                        lang = fullLang;
                    }
                }
                
                // 表示用言語名
                let displayLang = lang;
                if (lang === 'js') displayLang = 'JavaScript';
                if (lang === 'ts') displayLang = 'TypeScript';
                if (lang === 'py') displayLang = 'Python';
                if (lang === 'sh') displayLang = 'Bash';
                if (['ps1', 'pwsh', 'powershell'].includes(lang.toLowerCase())) displayLang = 'PowerShell';

                // 2. 元のソースコードを保存 (Highlight前の純粋なテキスト)
                const originalText = code.textContent;
                const lines = originalText.split(/\r\n|\r|\n/);
                const totalLines = lines.length;
                
                // 3. Highlight用クラス設定
                code.className = `language-${lang}`;
                code.innerHTML = ''; // 一旦空にする

                // 4. ラッパーとヘッダーの作成
                const wrapper = document.createElement('div');
                wrapper.className = 'code-wrapper';

                const header = document.createElement('div');
                header.className = 'code-header';
                
                const leftDiv = document.createElement('div');
                leftDiv.className = 'header-left';
                if (title) {
                    const tSpan = document.createElement('span');
                    tSpan.className = 'code-title';
                    tSpan.textContent = title;
                    leftDiv.appendChild(tSpan);
                }
                const lSpan = document.createElement('span');
                lSpan.className = 'code-lang';
                lSpan.textContent = displayLang;
                leftDiv.appendChild(lSpan);

                // Copy Button
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-btn';
                copyBtn.textContent = 'Copy';
                copyBtn.onclick = async () => {
                    try {
                        await navigator.clipboard.writeText(originalText);
                        copyBtn.textContent = 'Copied!';
                        setTimeout(() => copyBtn.textContent = 'Copy', 2000);
                    } catch(e) { copyBtn.textContent = 'Error'; }
                };

                header.appendChild(leftDiv);
                header.appendChild(copyBtn);

                // DOM組み換え: preをwrapperに入れる
                pre.parentNode.insertBefore(wrapper, pre);
                wrapper.appendChild(header);
                wrapper.appendChild(pre);

                // 5. 省略ロジック or 通常表示
                if (totalLines > FOLD_THRESHOLD) {
                    renderSnipped(code, lines, lang);
                } else {
                    renderFull(code, originalText);
                }
            });
        }

        // 通常表示 (Highlightのみ)
        function renderFull(codeElement, text) {
            codeElement.textContent = text;
            hljs.highlightElement(codeElement);
        }

        // 省略表示 (Top10 + Snip + Bottom10)
        function renderSnipped(codeElement, lines, lang) {
            const headLines = lines.slice(0, SHOW_LINES);
            const tailLines = lines.slice(-SHOW_LINES);
            const hiddenCount = lines.length - (SHOW_LINES * 2);

            // 前半部分
            const headText = headLines.join('\n');
            // 後半部分
            const tailText = tailLines.join('\n');

            // ハイライト適用 (個別に適用して結合する)
            // ※注意: ブロックまたぎのコメントなどは切れる可能性があるが、簡易ビューアとしては許容範囲とする
            
            // 1. 前半のレンダリング
            // ダミー要素を作ってHighlightさせる
            const headDummy = document.createElement('div');
            headDummy.textContent = headText;
            // クラスをセットしないとauto detectionが走るが、指定言語でhighlightさせたい
            // hljs.highlight(text, {language: ...}) を使う
            let headHtml = hljs.highlight(headText, { language: lang, ignoreIllegals: true }).value;
            
            // 2. 後半のレンダリング
            let tailHtml = hljs.highlight(tailText, { language: lang, ignoreIllegals: true }).value;

            // 3. 省略バー (クリックで展開)
            const snipDiv = document.createElement('div');
            snipDiv.className = 'snip-line';
            snipDiv.textContent = `... snip (${hiddenCount} lines hidden) ... Click to expand all`;
            
            snipDiv.onclick = () => {
                // クリックされたら全展開
                const fullText = lines.join('\n');
                codeElement.innerHTML = ''; // クリア
                codeElement.textContent = fullText;
                hljs.highlightElement(codeElement); // 再ハイライト
            };

            // DOMに流し込み
            codeElement.innerHTML = headHtml + '\n'; // 改行を入れておく
            codeElement.appendChild(snipDiv);
            codeElement.insertAdjacentHTML('beforeend', tailHtml);
        }

        loadMarkdown();
    </script>
</body>
</html>
