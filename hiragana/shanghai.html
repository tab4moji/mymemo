<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>„Éî„É≥„ÉÅ„Ç∫„Éº„É†ÔºÜ„Éâ„É©„ÉÉ„Ç∞ÂØæÂøú„ÇΩ„É™„ÉÜ„Ç£„Ç¢„Ç®„É≥„Ç∏„É≥</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }
        body {
            font-family: sans-serif;
            background-color: #0b4f32;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .hidden { display: none !important; }
        #start-screen {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            width: 100vw;
            height: 100vh;
        }
        #start-screen h1 { font-size: 4em; text-shadow: 3px 3px 5px rgba(0,0,0,0.5); z-index: 1; }
        #start-button { font-size: 2em; padding: 15px 40px; border: 3px solid #fff; background-color: rgba(255,255,255,0.1); color: #fff; cursor: pointer; transition: background-color 0.3s, transform 0.1s; z-index: 1;}
        #start-button:hover { background-color: rgba(255,255,255,0.3); }
        #start-button:active { transform: scale(0.95); }
        #start-background-container, #game-container {
            position: absolute;
            top: 0; left: 0; width: 100vw; height: 100vh;
            overflow: hidden;
            cursor: grab;
        }
        #start-background-container:active, #game-container:active { cursor: grabbing; }
        #start-background-container {
            z-index: 0;
            opacity: 0.15;
            filter: blur(1px);
        }
        #start-background-board, #game-board {
            position: absolute;
            left: 0; top: 0;
            transform-origin: 0 0;
        }
        #game-view {
            width: 100vw; height: 100vh;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #game-view-header, #game-view-footer {
            position: absolute; width: 100%; text-align: center; z-index: 10;
            background-color: rgba(11, 79, 50, 0.7); padding: 1vh 0; pointer-events: none;
        }
        #game-view-header { top: 0; }
        #game-view-footer { bottom: 0; }
        #game-title { font-size: 2em; margin: 0; }
        #message-area { font-size: 1.5em; font-weight: bold; margin: 0; }
        .card {
            width: 60px; height: 84px; font-size: 24px;
            position: absolute;
            background-color: #fff;
            border: 1px solid #333;
            border-radius: 5%;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-weight: bold;
            transition: opacity 0.3s;
            transform-style: preserve-3d;
            user-select: none;
            -webkit-user-select: none;
        }
        .card[data-color="red"] { color: #d00; }
        .card[data-color="black"] { color: #000; }
        .card.selectable { cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 0 15px 5px #ff0, 2px 2px 5px rgba(0,0,0,0.3); }
        .card.selected { transform: translateY(-10px) scale(1.05); box-shadow: 0 0 20px 8px #0af, 2px 2px 5px rgba(0,0,0,0.3); }
        .card.removed { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>
    <div id="start-screen">
        <div id="start-background-container">
            <div id="start-background-board"></div>
        </div>
        <h1>„Éï„É©„ÇØ„Çø„É´„Éª„ÇΩ„É™„ÉÜ„Ç£„Ç¢</h1>
        <button id="start-button">„Ç≤„Éº„É†ÈñãÂßã</button>
    </div>
    <div id="game-view" class="hidden">
        <div id="game-container">
            <div id="game-board"></div>
        </div>
        <div id="game-view-header"><h1 id="game-title"></h1></div>
        <div id="game-view-footer"><div id="message-area"></div></div>
    </div>
<script>
/**
 * Êõ¥Êñ∞Â±•Ê≠¥
 * 1. 2025-06-19: „Éó„É≠„Ç∞„É©„É†„ÅÆÁõÆÁöÑ„Å®Ê©üËÉΩ
 *    - „Éî„É≥„ÉÅ„Ç∫„Éº„É†„ÄÅ„Éâ„É©„ÉÉ„Ç∞Êìç‰Ωú„ÅåÂèØËÉΩ„Å™„ÇΩ„É™„ÉÜ„Ç£„Ç¢„Ç≤„Éº„É†„Ç®„É≥„Ç∏„É≥„ÄÇ
 *    - „Çª„É´„Ç™„Éº„Éà„Éû„Éà„É≥„Å´„Çà„Çã„Éó„É≠„Ç∑„Éº„Ç∏„É£„É´„Å™„Çπ„ÉÜ„Éº„Ç∏ÁîüÊàê„ÄÇ
 *    - „ÇØ„É™„Ç¢‰øùË®º„ÅÆ„Å™„ÅÑ„ÉÄ„Éü„Éº„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÇíÊê≠Ëºâ„ÄÇ
 *    - „Ç≠„Éº„ÉØ„Éº„Éâ: procedural generation, cellular automata, pinch zoom, drag
 *
 * 2. 2025-06-19: „ÇØ„É™„Ç¢‰øùË®º„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÅÆÂÆüË£Ö
 *    - Ë®≠Ë®àÊõ∏„Å´Âü∫„Å•„Åç„ÄÅ„ÇØ„É™„Ç¢„Åå‰øùË®º„Åï„Çå„Çã„Çπ„ÉÜ„Éº„Ç∏ÁîüÊàê„É≠„Ç∏„ÉÉ„ÇØ„Å´‰øÆÊ≠£„ÄÇ
 *    - „Ç≠„Éº„ÉØ„Éº„Éâ: createSolveProcedure, solvable, reverse simulation, boardMap
 *
 * 3. 2025-06-19: ÊßãÊñá„Ç®„É©„Éº„ÅÆ‰øÆÊ≠£
 *    - ‰∏çÈÅ©Âàá„Å´‰∏ÄË°å„Å´ÂúßÁ∏Æ„Åï„Çå„Å¶„ÅÑ„ÅüË£úÂä©Èñ¢Êï∞„ÇíÂÖÉ„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Å´Êàª„Åó„ÄÅSyntaxError„ÇíËß£Ê∂à„ÄÇ
 *    - „Ç≠„Éº„ÉØ„Éº„Éâ: formatting, SyntaxError, single-line function
 *
 * 4. 2025-06-19: ÊßãÊñá„Ç®„É©„Éº„ÅÆÂÜç‰øÆÊ≠£
 *    - ÂâçÂõû„ÅÆ‰øÆÊ≠£Êºè„Çå„ÇíËß£Ê∂à„ÄÇÂÖ®Ë£úÂä©Èñ¢Êï∞„ÇíÊ≠£„Åó„Åè„Éï„Ç©„Éº„Éû„ÉÉ„Éà„ÄÇ
 *    - „Ç≠„Éº„ÉØ„Éº„Éâ: formatting, SyntaxError, config object
 *
 * 5. 2025-06-19: Èõ£ÊòìÂ∫¶Ë™øÊï¥„Å®Êìç‰ΩúÊÄßÊîπÂñÑ
 *    - ‰ΩøÁî®„Åô„Çã„Ç´„Éº„Éâ„Çí„ÄåA, 2, 3, 4„Äç„Å®„Äå„Ç∏„Éß„Éº„Ç´„Éº„Äç„Å´ÈôêÂÆö„Åó„Å¶Èõ£ÊòìÂ∫¶„ÇíÂêë‰∏ä„ÄÇ
 *    - „Éâ„É©„ÉÉ„Ç∞Êìç‰Ωú„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„Çí `document` „Å´Ë®≠ÂÆö„Åó„ÄÅÈ´òÈÄü„Å™„Éû„Ç¶„ÇπÁßªÂãï„Åß„ÇÇÊìç‰Ωú„ÅåÈÄîÂàá„Çå„Å™„ÅÑ„Çà„ÅÜ„Å´ÊîπÂñÑ„ÄÇ
 *    - „Ç≠„Éº„ÉØ„Éº„Éâ: difficulty, card set, basePairs, drag, pointer events, document listener
 *
 * 6. 2025-06-19: „Çπ„Éû„Éº„Éà„Éï„Ç©„É≥„Åß„ÅÆ„Çø„ÉÉ„ÉóÊìç‰Ωú„ÅÆ‰øÆÊ≠£
 *    - „Çø„ÉÉ„Éó„Å®„Éâ„É©„ÉÉ„Ç∞„ÇíÂå∫Âà•„Åô„Çã„Åü„ÇÅ„ÅÆÈñæÂÄ§ÔºàÈÅä„Å≥Ôºâ„ÇíÂ∞éÂÖ•„ÄÇ
 *    - Êåá„ÅÆÁßªÂãïË∑ùÈõ¢„Åå„Çè„Åö„Åã„Å™Â†¥Âêà„ÅØ„Çø„ÉÉ„Éó„ÄÅ‰∏ÄÂÆöË∑ùÈõ¢„ÇíË∂Ö„Åà„Åü„Çâ„Éâ„É©„ÉÉ„Ç∞„Å®„Åó„Å¶Ë™çË≠ò„Åô„Çã„Çà„ÅÜ„Å´‰øÆÊ≠£„ÄÇ
 *    - „Ç≠„Éº„ÉØ„Éº„Éâ: touch, tap, drag threshold, pointer events, mobile usability
 */
(function() {
    'use strict';
    const gameManager = { currentLevel: 1, gameState: {} };

    class XorShift32 {
      /**
       * „Ç≥„É≥„Çπ„Éà„É©„ÇØ„Çø
       * @param {number} seed ÂàùÊúü„Ç∑„Éº„ÉâÔºà32bitÊï¥Êï∞, 0 „ÇíÈÅø„Åë„ÇãÔºâ
       */
      constructor(seed) {
        // 0 „Å†„Å®ÂÖ®„Éì„ÉÉ„Éà 0 „ÅÆ„Åæ„Åæ„Å´„Å™„Å£„Å¶„Åó„Åæ„ÅÜ„ÅÆ„Åß„ÄÅ„ÇÇ„Åó 0 „ÅåÊ∏°„Åï„Çå„Åü„ÇâÈÅ©ÂΩì„Å™ÂÄ§„Çí‰ª£ÂÖ•
        this.state = (seed >>> 0) || 0xDEADBEEF;
      }

      /**
       * Ê¨°„ÅÆ‰π±Êï∞„ÇíÁîüÊàê„Åó„Å¶Ëøî„Åô
       * @returns {number} 32bit „ÅÆÁ¨¶Âè∑„Å™„ÅóÊï¥Êï∞ (0 ‚Ä¶ 0xFFFFFFFF)
       */
      nextUInt32() {
        // xorshift32 „ÅÆ„Ç≥„Ç¢ (Marsaglia „ÅÆ„Ç™„É™„Ç∏„Éä„É´)
        let x = this.state;
        x ^= x << 13;
        x ^= x >>> 17;
        x ^= x << 5;
        // 32bit „Å´Âàá„ÇäË©∞„ÇÅ„Å¶Ë≤†„ÅÆÂÄ§„ÅåÂá∫„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã
        this.state = x >>> 0;
        return this.state;
      }

      /**
       * ‰π±Êï∞„Çí 0ÔΩû1 Êú™Ê∫Ä„ÅÆÊµÆÂãïÂ∞èÊï∞ÁÇπ„ÅßËøî„Åô
       * @returns {number} [0, 1)
       */
      random() {
        // 2^32 „ÅßÂâ≤„Å£„Å¶ [0,1) „ÅÆÁØÑÂõ≤„Å´Ê≠£Ë¶èÂåñ
        return this.nextUInt32() / 0x100000000;
      }
    }

    // ‰ΩøÁî®‰æã
    const XorShift = new XorShift32(12345 & 0xFFFFFFFF);


    // --- „Åì„Åì„Åã„Çâ„ÅåÂ§âÊõ¥ÁÆáÊâÄ (makeInteractiveÈñ¢Êï∞) ---
    function makeInteractive(containerId) {
        const container = document.getElementById(containerId);
        const board = container.querySelector('div');
        if (!board) return;

        let scale = 1, minScale = 0.2, maxScale = 3;
        let x = 0, y = 0;
        let pointerCache = [];
        let prevDiff = -1;
        let isDragging = false;
        let dragStartTarget = null;
        
        // „Çø„ÉÉ„Éó„Å®„Éâ„É©„ÉÉ„Ç∞„ÇíÂå∫Âà•„Åô„Çã„Åü„ÇÅ„ÅÆÈñæÂÄ§Ôºà„Éî„ÇØ„Çª„É´Âçò‰ΩçÔºâ
        const DRAG_THRESHOLD = 5;
        let startX = 0, startY = 0;


        const handlePointerDown = (ev) => {
            if (!container.contains(ev.target)) return;
            
            pointerCache.push(ev);
            
            if (pointerCache.length === 1) {
                isDragging = false;
                dragStartTarget = ev.target;
                // „Éâ„É©„ÉÉ„Ç∞ÈñãÂßãÂ∫ßÊ®ô„ÇíË®òÈå≤
                startX = ev.clientX;
                startY = ev.clientY;
            }

            document.addEventListener('pointermove', handlePointerMove);
            document.addEventListener('pointerup', handlePointerUp);
            document.addEventListener('pointercancel', handlePointerUp);
        };

        const handlePointerMove = (ev) => {
            const index = pointerCache.findIndex(cachedEv => cachedEv.pointerId === ev.pointerId);
            if (index > -1) {
                pointerCache[index] = ev;
            } else {
                return;
            }

            if (pointerCache.length === 1) {
                // „Éâ„É©„ÉÉ„Ç∞Âà§ÂÆö
                if (!isDragging) {
                    const dx = ev.clientX - startX;
                    const dy = ev.clientY - startY;
                    if (Math.sqrt(dx * dx + dy * dy) > DRAG_THRESHOLD) {
                        isDragging = true;
                    }
                }
                
                // „Éâ„É©„ÉÉ„Ç∞Áä∂ÊÖã„ÅÆÂ†¥Âêà„ÅÆ„ÅøÁõ§Èù¢„ÇíÁßªÂãï
                if (isDragging) {
                    x += ev.movementX;
                    y += ev.movementY;
                    board.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
                }
                ev.preventDefault();

            } else if (pointerCache.length === 2) {
                isDragging = true; // „Éî„É≥„ÉÅÊìç‰Ωú„ÅØÂ∏∏„Å´„Éâ„É©„ÉÉ„Ç∞„Å®Ë¶ã„Å™„Åô
                const p1 = pointerCache[0], p2 = pointerCache[1];
                const curDiff = Math.sqrt(Math.pow(p1.clientX - p2.clientX, 2) + Math.pow(p1.clientY - p2.clientY, 2));
                const midPoint = { x: (p1.clientX + p2.clientX) / 2, y: (p1.clientY + p2.clientY) / 2 };

                if (prevDiff > 0) {
                    const scaleChange = curDiff / prevDiff;
                    const newScale = Math.max(minScale, Math.min(scale * scaleChange, maxScale));
                    x = midPoint.x - (midPoint.x - x) * (newScale / scale);
                    y = midPoint.y - (midPoint.y - y) * (newScale / scale);
                    scale = newScale;
                }
                prevDiff = curDiff;
                board.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
                ev.preventDefault();
            }
        };

        const handlePointerUp = (ev) => {
            if (!isDragging && dragStartTarget && dragStartTarget.classList.contains('card')) {
                if (pointerCache.length > 0 && ev.pointerId === pointerCache.find(p => p.pointerId === ev.pointerId)?.pointerId) {
                   const cardId = parseInt(dragStartTarget.id.split('-').pop());
                   onCardClick(cardId);
                }
            }

            pointerCache = pointerCache.filter(p => p.pointerId !== ev.pointerId);
            
            if (pointerCache.length < 2) {
                prevDiff = -1;
            }

            if (pointerCache.length === 0) {
                document.removeEventListener('pointermove', handlePointerMove);
                document.removeEventListener('pointerup', handlePointerUp);
                document.removeEventListener('pointercancel', handlePointerUp);
                dragStartTarget = null;
                isDragging = false;
            }
        };

        container.addEventListener('pointerdown', handlePointerDown);
        
        board.addEventListener('dragstart', (e) => e.preventDefault());

        container.addEventListener('wheel', (ev) => {
            ev.preventDefault();
            const scaleChange = ev.deltaY * -0.001;
            const newScale = Math.max(minScale, Math.min(scale * (1 + scaleChange), maxScale));
            x = ev.clientX - (ev.clientX - x) * (newScale / scale);
            y = ev.clientY - (ev.clientY - y) * (newScale / scale);
            scale = newScale;
            board.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
        });
    }

    function setBoardSizeAndPosition(cards, boardId) {
        const boardEl = document.getElementById(boardId);
        if (!cards || cards.length === 0 || !boardEl) return;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        cards.forEach(card => { minX = Math.min(minX, card.coords.x); maxX = Math.max(maxX, card.coords.x + 2); minY = Math.min(minY, card.coords.y); maxY = Math.max(maxY, card.coords.y + 2); });
        const cardWidth = 60;
        const cardHeight = 84;
        const boardPixelWidth = (maxX - minX) / 2 * cardWidth;
        const boardPixelHeight = (maxY - minY) / 2 * cardHeight;
        boardEl.style.width = `${boardPixelWidth}px`;
        boardEl.style.height = `${boardPixelHeight}px`;

        boardEl.querySelectorAll('.card').forEach(cardEl => {
            const cardId = parseInt(cardEl.id.split('-').pop());
            const cardData = cards.find(c => c.id === cardId);
            if (cardData) {
                const left = (cardData.coords.x - minX) / 2 * cardWidth;
                const top = (cardData.coords.y - minY) / 2 * cardHeight;
                cardEl.style.left = `${left}px`;
                cardEl.style.top = `${top}px`;
            }
        });

        const container = boardEl.parentElement;
        const containerRect = container.getBoundingClientRect();
        boardEl.style.left = `${(containerRect.width - boardPixelWidth)/2}px`;
        boardEl.style.top = `${(containerRect.height - boardPixelHeight)/2}px`;
        boardEl.style.transform = `translate(0, 0) scale(1)`;
    }

    function showStartScreen() {
        document.getElementById('start-screen').classList.remove('hidden');
        document.getElementById('game-view').classList.add('hidden');
        renderFractalBackground();
    }

    function renderFractalBackground() {
        const baseShape = generateCellularAutomataShape(20, 15);
        const proceduralLayout = generateProceduralLayout(baseShape);
        const { cards } = generateStructuralLayout(proceduralLayout);
        const requiredPairs = cards.length / 2;

        const basePairs = [
            ...Array.from({length: 4}, (_, i) => [{type: 'card', rank: i + 1, suit: 'heart', color: 'red'}, {type: 'card', rank: i + 1, suit: 'diamond', color: 'red'}]),
            ...Array.from({length: 4}, (_, i) => [{type: 'card', rank: i + 1, suit: 'spade', color: 'black'}, {type: 'card', rank: i + 1, suit: 'club', color: 'black'}]),
            [{type: 'joker', rank: 0, suit: 'joker', color: 'black'}, {type: 'joker', rank: 0, suit: 'joker', color: 'red'}]
        ];
        const content = {
            basePairs: basePairs,
            sets: Math.ceil(requiredPairs / basePairs.length)
        };

        const logicalPairs = generateContentSet(content, requiredPairs);
        if(!logicalPairs) return;
        const solveProcedure = createDummySolveProcedure(cards);
        assignCardsContent(cards, solveProcedure, logicalPairs);
        const display = {
            renderer: (card) => {
                const RANKS = { 0: 'ü§°', 1: 'A', 11: 'J', 12: 'Q', 13: 'K' };
                const SUITS = { spade: '‚ô†', heart: '‚ô•', diamond: '‚ô¶', club: '‚ô£', joker: 'üåõ' };
                const rank = RANKS[card.rank] || (card.rank > 0 && card.rank < 11 ? card.rank : '');
                const suit = SUITS[card.suit];
                return rank || suit ? `${rank}<br>${suit}` : '';
            }
        };
        renderBoard(cards, display, 'start-background-board');
        setBoardSizeAndPosition(cards, 'start-background-board');
    }

    function startGame(level) {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-view').classList.remove('hidden');
        const baseSize = 5 + level;
        const baseShape = generateCellularAutomataShape(baseSize, baseSize);
        const proceduralLayout = generateProceduralLayout(baseShape);
        const { cards, boardMap } = generateStructuralLayout(proceduralLayout);
        if(cards.length < 10) {
            startGame(level);
            return;
        }
        const requiredPairs = cards.length / 2;
        
        const basePairs = [
            ...Array.from({length: 4}, (_, i) => [{type: 'card', rank: i + 1, suit: 'heart', color: 'red'}, {type: 'card', rank: i + 1, suit: 'diamond', color: 'red'}]),
            ...Array.from({length: 4}, (_, i) => [{type: 'card', rank: i + 1, suit: 'spade', color: 'black'}, {type: 'card', rank: i + 1, suit: 'club', color: 'black'}]),
            [{type: 'joker', rank: 0, suit: 'joker', color: 'black'}, {type: 'joker', rank: 0, suit: 'joker', color: 'red'}]
        ];
        const requiredSets = Math.ceil(requiredPairs / basePairs.length);
        const config = {
            title: `„É¨„Éô„É´ ${level}`,
            initialData: { cards, boardMap },
            content: {
                sets: requiredSets,
                basePairs: basePairs
            },
            display: {
                renderer: (card) => {
                    const RANKS = { 0: 'ü§°', 1: 'A', 11: 'J', 12: 'Q', 13: 'K' };
                    const SUITS = { spade: '‚ô†', heart: '‚ô•', diamond: '‚ô¶', club: '‚ô£', joker: 'üåõ' };
                    const rank = RANKS[card.rank] || (card.rank > 0 && card.rank < 11 ? card.rank : '');
                    const suit = SUITS[card.suit];
                    return rank || suit ? `${rank}<br>${suit}` : '';
                }
            }
        };
        main(config);
    }

    document.addEventListener('DOMContentLoaded', () => {
        makeInteractive('start-background-container');
        makeInteractive('game-container');
        showStartScreen();
        document.getElementById('start-button').addEventListener('click', () => startGame(gameManager.currentLevel));
    });

    function main(config) {
        document.getElementById('game-title').textContent = config.title;
        setupGame(config);
    }

    function setupGame(config) {
        const { cards, boardMap } = config.initialData;
        gameManager.gameState = { cards, boardMap, selectedCards: [], gameStatus: 'playing', pairsLeft: cards.length / 2 };
        const solveProcedure = createSolveProcedure(boardMap, cards);
        if (!solveProcedure) {
            console.error("„ÇØ„É™„Ç¢ÊâãÈ†Ü„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„É™„Éà„É©„Ç§„Åó„Åæ„Åô„ÄÇ");
            startGame(gameManager.currentLevel);
            return;
        }
        const logicalPairs = generateContentSet(config.content, gameManager.gameState.pairsLeft);
        if (!logicalPairs) {
            console.error("„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆ„Éö„Ç¢Êï∞„ÅåË∂≥„Çä„Åæ„Åõ„Çì„ÄÇ");
            return;
        }
        assignCardsContent(cards, solveProcedure, logicalPairs);
        renderBoard(cards, config.display, 'game-board');
        setBoardSizeAndPosition(cards, 'game-board');
        updateSelectableStatus();
        updateMessage("„Éö„Ç¢„ÇíË¶ã„Å§„Åë„Å¶„Åè„Å†„Åï„ÅÑ");
    }

    function renderBoard(cards, displayConfig, targetElementId) {
        const { renderer } = displayConfig;
        const boardEl = document.getElementById(targetElementId);
        if (!boardEl) return;
        boardEl.innerHTML = '';
        cards.forEach(card => {
            const cardEl = document.createElement('div');
            cardEl.id = `${targetElementId}-card-${card.id}`;
            cardEl.className = 'card';
            cardEl.innerHTML = renderer(card);
            if (card.color) cardEl.dataset.color = card.color;
            cardEl.style.zIndex = card.coords.z * 1000 + card.coords.y * 10;
            boardEl.appendChild(cardEl);
        });
    }

    function onCardClick(cardId) {
        if (gameManager.gameState.gameStatus !== 'playing') return;
        const clickedCard = gameManager.gameState.cards.find(c => c.id === cardId);
        if (!clickedCard || !clickedCard.isSelectable) return;
        const selectedIndex = gameManager.gameState.selectedCards.findIndex(c => c.id === cardId);
        if (selectedIndex > -1) {
            gameManager.gameState.selectedCards.splice(selectedIndex, 1);
            document.querySelector(`#game-board-card-${cardId}`).classList.remove('selected');
        } else {
            gameManager.gameState.selectedCards.push(clickedCard);
            document.querySelector(`#game-board-card-${cardId}`).classList.add('selected');
        }
        if (gameManager.gameState.selectedCards.length === 2) {
            if (isPair(gameManager.gameState.selectedCards[0], gameManager.gameState.selectedCards[1])) {
                removePair(gameManager.gameState.selectedCards);
                updateSelectableStatus();
                checkGameEnd();
            } else {
                updateMessage("„Éö„Ç¢„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„ÇìÔºÅ");
                setTimeout(() => { if (gameManager.gameState.gameStatus === 'playing') updateMessage("„Éö„Ç¢„ÇíË¶ã„Å§„Åë„Å¶„Åè„Å†„Åï„ÅÑ"); }, 1500);
            }
            gameManager.gameState.selectedCards.forEach(c => document.querySelector(`#game-board-card-${c.id}`)?.classList.remove('selected'));
            gameManager.gameState.selectedCards = [];
        }
    }

    function createSolveProcedure(initialBoardMap, initialCards) {
        const MAX_ATTEMPTS = 10;
        const isSelectableInSimulation = (card, boardMap) => {
            if (card.isRemoved) return false;
            const { x, y, z } = card.coords;
            const maxZ = boardMap.length - 1;
            if (z < maxZ) {
                const upperLayer = boardMap[z + 1];
                for (let dy = 0; dy < 2; dy++) {
                    for (let dx = 0; dx < 2; dx++) {
                        if (upperLayer[y + dy] && upperLayer[y + dy][x + dx] !== null) {
                            return false;
                        }
                    }
                }
            }
            const currentLayer = boardMap[z];
            const boardWidth = currentLayer[0].length;
            const isLeftOpen = (x === 0) || (currentLayer[y][x - 1] === null && currentLayer[y + 1][x - 1] === null);
            const isRightOpen = (x + 2 >= boardWidth) || (currentLayer[y][x + 2] === null && currentLayer[y + 1][x + 2] === null);
            return isLeftOpen || isRightOpen;
        };
        for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
            let tempBoardMap = JSON.parse(JSON.stringify(initialBoardMap));
            let tempCards = JSON.parse(JSON.stringify(initialCards));
            const procedure = [];
            let remainingCards = tempCards.length;
            let possible = true;
            while (remainingCards > 0) {
                const selectableCards = tempCards.filter(card => !card.isRemoved && isSelectableInSimulation(card, tempBoardMap));
                if (selectableCards.length < 2) {
                    possible = false;
                    break;
                }
                for (let i = selectableCards.length - 1; i > 0; i--) {
                    const j = Math.floor(XorShift.random() * (i + 1));
                    [selectableCards[i], selectableCards[j]] = [selectableCards[j], selectableCards[i]];
                }
                const pair = [selectableCards[0], selectableCards[1]];
                procedure.push([pair[0].id, pair[1].id]);
                for (const card of pair) {
                    const cardInSim = tempCards.find(c => c.id === card.id);
                    cardInSim.isRemoved = true;
                    const { x, y, z } = card.coords;
                    for (let dy = 0; dy < 2; dy++) {
                        for (let dx = 0; dx < 2; dx++) {
                            tempBoardMap[z][y + dy][x + dx] = null;
                        }
                    }
                }
                remainingCards -= 2;
            }
            if (possible && remainingCards === 0) {
                return procedure.reverse();
            }
        }
        console.error("„ÇØ„É™„Ç¢ÊâãÈ†Ü„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„ÅüÔºàÊúÄÂ§ßË©¶Ë°åÂõûÊï∞Ë∂ÖÈÅéÔºâ");
        return null;
    }
    
    function createDummySolveProcedure(cards) {
        const shuffledIds = cards.map(c => c.id).sort(() => 0.5 - XorShift.random());
        const procedure = [];
        for (let i = 0; i < shuffledIds.length; i += 2) {
            if (shuffledIds[i+1]) procedure.push([shuffledIds[i], shuffledIds[i+1]]);
        }
        return procedure;
    }

    function generateCellularAutomataShape(width, height, generations = 4, birthThreshold = 5, survivalThreshold = 4) {
        let grid = Array.from({length: height}, () => Array(width).fill(false));
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (XorShift.random() < 0.45) grid[y][x] = true;
            }
        }
        for (let i = 0; i < generations; i++) {
            const newGrid = Array.from({length: height}, () => Array(width).fill(false));
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let neighbours = 0;
                    for (let ny = -1; ny <= 1; ny++) {
                        for (let nx = -1; nx <= 1; nx++) {
                            if (ny === 0 && nx === 0) continue;
                            const checkX = x + nx;
                            const checkY = y + ny;
                            if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height && grid[checkY][checkX]) {
                                neighbours++;
                            }
                        }
                    }
                    if (grid[y][x]) {
                        if (neighbours >= survivalThreshold) newGrid[y][x] = true;
                    } else {
                        if (neighbours >= birthThreshold) newGrid[y][x] = true;
                    }
                }
            }
            grid = newGrid;
        }
        return grid;
    }

    function checkGameEnd() {
        if (gameManager.gameState.pairsLeft === 0) {
            gameManager.gameState.gameStatus = 'cleared';
            updateMessage(`„É¨„Éô„É´ ${gameManager.currentLevel} „ÇØ„É™„Ç¢ÔºÅ`);
            setTimeout(() => {
                gameManager.currentLevel++;
                startGame(gameManager.currentLevel);
            }, 3000);
            return;
        }
        const selectableCards = gameManager.gameState.cards.filter(c => c.isSelectable);
        const possiblePairs = new Map();
        let foundPair = false;
        for (const card of selectableCards) {
            const key = card.type === 'joker' ? 'joker' : (card.char ? card.char : `${card.color}-${card.rank}`);
            if (possiblePairs.has(key)) {
                foundPair = true;
                break;
            }
            possiblePairs.set(key, true);
        }
        if (!foundPair) {
            gameManager.gameState.gameStatus = 'stuck';
            updateMessage("ÊâãË©∞„Åæ„Çä„Åß„Åô...");
        } else {
            updateMessage(`${gameManager.gameState.pairsLeft} „Éö„Ç¢ÊÆã„Çä`);
        }
    }

    function generateProceduralLayout(baseShape) {
        const fullLayoutDef = [baseShape];
        let currentLayerDef = baseShape;
        while (true) {
            const nextLayerDef = [];
            let hasCardInNextLayer = false;
            const prevHeight = currentLayerDef.length;
            const prevWidth = prevHeight > 0 ? currentLayerDef[0].length : 0;
            for (let y = 0; y < prevHeight - 1; y++) {
                nextLayerDef[y] = [];
                for (let x = 0; x < prevWidth - 1; x++) {
                    const canPlace = currentLayerDef[y][x] && currentLayerDef[y][x+1] && currentLayerDef[y+1][x] && currentLayerDef[y+1][x+1];
                    nextLayerDef[y][x] = canPlace;
                    if (canPlace) hasCardInNextLayer = true;
                }
            }
            if (!hasCardInNextLayer) break;
            fullLayoutDef.push(nextLayerDef);
            currentLayerDef = nextLayerDef;
        }
        return fullLayoutDef;
    }

    function generateStructuralLayout(layoutDef) {
        const cards = [];
        let cardId = 1;
        const baseLayer = layoutDef[0] || [];
        const baseHeight = baseLayer.length;
        const baseWidth = baseHeight > 0 ? baseLayer[0].length : 0;
        const maxLayers = layoutDef.length;
        const totalGridWidth = baseWidth * 2 + maxLayers - 1;
        const totalGridHeight = baseHeight * 2 + maxLayers - 1;
        const boardMap = Array.from({ length: maxLayers }, () => Array.from({ length: totalGridHeight }, () => Array(totalGridWidth).fill(null)));
        layoutDef.forEach((layer, z) => {
            layer.forEach((row, y) => {
                row.forEach((hasCard, x) => {
                    if (hasCard) {
                        const gridX = x * 2 + z;
                        const gridY = y * 2 + z;
                        const newCard = { id: cardId++, coords: { x: gridX, y: gridY, z }, isRemoved: false, isSelectable: false };
                        cards.push(newCard);
                        for (let dy = 0; dy < 2; dy++) {
                            for (let dx = 0; dx < 2; dx++) {
                                boardMap[z][gridY + dy][gridX + dx] = newCard.id;
                            }
                        }
                    }
                });
            });
        });
        if (cards.length % 2 !== 0) {
            const cardToRemove = cards.pop();
            const {x, y, z} = cardToRemove.coords;
            for (let dy = 0; dy < 2; dy++) {
                for (let dx = 0; dx < 2; dx++) {
                    boardMap[z][y + dy][x + dx] = null;
                }
            }
        }
        return { cards, boardMap };
    }

    function generateContentSet(contentConfig, requiredPairs) {
        const { basePairs, sets } = contentConfig;
        const allPairs = [];
        for (let i = 0; i < sets; i++) {
            allPairs.push(...JSON.parse(JSON.stringify(basePairs)));
        }
        if (allPairs.length < requiredPairs) {
            return null;
        }
        for (let i = allPairs.length - 1; i > 0; i--) {
            const j = Math.floor(XorShift.random() * (i + 1));
            [allPairs[i], allPairs[j]] = [allPairs[j], allPairs[i]];
        }
        return allPairs.slice(0, requiredPairs);
    }

    function assignCardsContent(cards, solveProcedure, logicalPairs) {
        for (const idPair of solveProcedure) {
            const logicalPair = logicalPairs.pop();
            if (!logicalPair) {
                console.error("Ë´ñÁêÜ„Éö„Ç¢„ÅÆÊï∞„ÅåË∂≥„Çä„Åæ„Åõ„Çì„ÄÇ");
                break;
            }
            const card1 = cards.find(c => c.id === idPair[0]);
            const card2 = cards.find(c => c.id === idPair[1]);
            if(card1 && card2) {
                Object.assign(card1, logicalPair[0]);
                Object.assign(card2, logicalPair[1]);
            } else {
                console.error("ID„Å´ÂØæÂøú„Åô„Çã„Ç´„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì:", idPair);
            }
        }
    }

    function isPair(card1, card2) {
        if (!card1 || !card2) return false;
        if (card1.type === 'joker' && card2.type === 'joker') return true;
        if (card1.color === card2.color && card1.rank === card2.rank) return true;
        if(card1.char && card1.char === card2.char) return true;
        return false;
    }

    function updateSelectableStatus() {
        gameManager.gameState.cards.forEach(card => {
            if (card.isRemoved) return;
            const wasSelectable = card.isSelectable;
            card.isSelectable = isCardSelectable(card, gameManager.gameState.boardMap);
            const cardEl = document.getElementById(`game-board-card-${card.id}`);
            if(cardEl){
                if (card.isSelectable && !wasSelectable) {
                    cardEl.classList.add('selectable');
                } else if (!card.isSelectable && wasSelectable) {
                    cardEl.classList.remove('selectable');
                }
            }
        });
    }

    function isCardSelectable(card, boardMap) {
        if (card.isRemoved) return false;
        const { x, y, z } = card.coords;
        const currentLayer = boardMap[z];
        const upperLayer = boardMap[z + 1];
        if (upperLayer) {
            for (let dy = 0; dy < 2; dy++) {
                for (let dx = 0; dx < 2; dx++) {
                    const checkY = y + dy;
                    const checkX = x + dx;
                    if (upperLayer[checkY] && upperLayer[checkY][checkX] !== null) {
                        return false;
                    }
                }
            }
        }
        const isLeftOpen = (x < 1) || (currentLayer[y][x - 1] === null && currentLayer[y + 1][x - 1] === null);
        const isRightOpen = (x + 2 >= currentLayer[0].length) || (currentLayer[y][x + 2] === null && currentLayer[y + 1][x + 2] === null);
        return isLeftOpen || isRightOpen;
    }

    function updateMessage(text) {
        document.getElementById('message-area').textContent = text;
    }

    function removePair(cards) {
        for (const card of cards) {
            card.isRemoved = true;
            const cardEl = document.getElementById(`game-board-card-${card.id}`);
            cardEl.classList.add('removed');
            cardEl.classList.remove('selectable', 'selected');
            for (let dy = 0; dy < 2; dy++) {
                for (let dx = 0; dx < 2; dx++) {
                    const finalY = Math.floor(card.coords.y + dy);
                    const finalX = Math.floor(card.coords.x + dx);
                    if (gameManager.gameState.boardMap[card.coords.z] && gameManager.gameState.boardMap[card.coords.z][finalY]) {
                        gameManager.gameState.boardMap[card.coords.z][finalY][finalX] = null;
                    }
                }
            }
        }
        gameManager.gameState.pairsLeft--;
    }
})();
</script>
</body>
</html>
