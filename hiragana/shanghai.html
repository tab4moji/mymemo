<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ï¼†ãƒ‰ãƒ©ãƒƒã‚°å¯¾å¿œã‚½ãƒªãƒ†ã‚£ã‚¢ã‚¨ãƒ³ã‚¸ãƒ³</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }
        body {
            font-family: sans-serif;
            background-color: #0b4f32;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .hidden { display: none !important; }
        #start-screen {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            width: 100vw;
            height: 100vh;
        }
        #start-screen h1 { font-size: 4em; text-shadow: 3px 3px 5px rgba(0,0,0,0.5); z-index: 1; }
        #start-button { font-size: 2em; padding: 15px 40px; border: 3px solid #fff; background-color: rgba(255,255,255,0.1); color: #fff; cursor: pointer; transition: background-color 0.3s, transform 0.1s; z-index: 1;}
        #start-button:hover { background-color: rgba(255,255,255,0.3); }
        #start-button:active { transform: scale(0.95); }
        #start-background-container, #game-container {
            position: absolute;
            top: 0; left: 0; width: 100vw; height: 100vh;
            overflow: hidden;
            cursor: grab;
        }
        #start-background-container:active, #game-container:active { cursor: grabbing; }
        #start-background-container {
            z-index: 0;
            opacity: 0.15;
            filter: blur(1px);
        }
        #start-background-board, #game-board {
            position: absolute;
            left: 0; top: 0;
            transform-origin: 0 0;
        }
        #game-view {
            width: 100vw; height: 100vh;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #game-view-header, #game-view-footer {
            position: absolute; width: 100%; text-align: center; z-index: 10;
            background-color: rgba(11, 79, 50, 0.7); padding: 1vh 0; pointer-events: none;
        }
        #game-view-header { top: 0; }
        #game-view-footer { bottom: 0; }
        #game-title { font-size: 2em; margin: 0; }
        #message-area { font-size: 1.5em; font-weight: bold; margin: 0; }
        .card {
            width: 60px; height: 84px; font-size: 24px;
            position: absolute;
            background-color: #fff;
            border: 1px solid #333;
            border-radius: 5%;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-weight: bold;
            transition: opacity 0.3s;
            transform-style: preserve-3d;
            user-select: none;
            -webkit-user-select: none;
        }
        .card[data-color="red"] { color: #d00; }
        .card[data-color="black"] { color: #000; }
        .card.selectable { cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 0 15px 5px #ff0, 2px 2px 5px rgba(0,0,0,0.3); }
        .card.selected { transform: translateY(-10px) scale(1.05); box-shadow: 0 0 20px 8px #0af, 2px 2px 5px rgba(0,0,0,0.3); }
        .card.removed { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>
    <div id="start-screen">
        <div id="start-background-container">
            <div id="start-background-board"></div>
        </div>
        <h1>ãƒ•ãƒ©ã‚¯ã‚¿ãƒ«ãƒ»ã‚½ãƒªãƒ†ã‚£ã‚¢</h1>
        <button id="start-button">ã‚²ãƒ¼ãƒ é–‹å§‹</button>
    </div>
    <div id="game-view" class="hidden">
        <div id="game-container">
            <div id="game-board"></div>
        </div>
        <div id="game-view-header"><h1 id="game-title"></h1></div>
        <div id="game-view-footer"><div id="message-area"></div></div>
    </div>
<script>
/**
 * æ›´æ–°å±¥æ­´
 * 1. 2025-06-19: ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ç›®çš„ã¨æ©Ÿèƒ½
 *    - ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ã€ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œãŒå¯èƒ½ãªã‚½ãƒªãƒ†ã‚£ã‚¢ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã€‚
 *    - ã‚»ãƒ«ã‚ªãƒ¼ãƒˆãƒãƒˆãƒ³ã«ã‚ˆã‚‹ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£ãƒ«ãªã‚¹ãƒ†ãƒ¼ã‚¸ç”Ÿæˆã€‚
 *    - ã‚¯ãƒªã‚¢ä¿è¨¼ã®ãªã„ãƒ€ãƒŸãƒ¼ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’æ­è¼‰ã€‚
 *    - ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: procedural generation, cellular automata, pinch zoom, drag
 *
 * 2. 2025-06-19: ã‚¯ãƒªã‚¢ä¿è¨¼ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿè£…
 *    - è¨­è¨ˆæ›¸ã«åŸºã¥ãã€ã‚¯ãƒªã‚¢ãŒä¿è¨¼ã•ã‚Œã‚‹ã‚¹ãƒ†ãƒ¼ã‚¸ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ã«ä¿®æ­£ã€‚
 *    - ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: createSolveProcedure, solvable, reverse simulation, boardMap
 *
 * 3. 2025-06-19: æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã®ä¿®æ­£
 *    - ä¸é©åˆ‡ã«ä¸€è¡Œã«åœ§ç¸®ã•ã‚Œã¦ã„ãŸè£œåŠ©é–¢æ•°ã‚’å…ƒã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«æˆ»ã—ã€SyntaxErrorã‚’è§£æ¶ˆã€‚
 *    - ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: formatting, SyntaxError, single-line function
 *
 * 4. 2025-06-19: æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã®å†ä¿®æ­£
 *    - å‰å›ã®ä¿®æ­£æ¼ã‚Œã‚’è§£æ¶ˆã€‚å…¨è£œåŠ©é–¢æ•°ã‚’æ­£ã—ããƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã€‚
 *    - ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: formatting, SyntaxError, config object
 *
 * 5. 2025-06-19: é›£æ˜“åº¦èª¿æ•´ã¨æ“ä½œæ€§æ”¹å–„
 *    - ä½¿ç”¨ã™ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’ã€ŒA, 2, 3, 4ã€ã¨ã€Œã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼ã€ã«é™å®šã—ã¦é›£æ˜“åº¦ã‚’å‘ä¸Šã€‚
 *    - ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ `document` ã«è¨­å®šã—ã€é«˜é€Ÿãªãƒã‚¦ã‚¹ç§»å‹•ã§ã‚‚æ“ä½œãŒé€”åˆ‡ã‚Œãªã„ã‚ˆã†ã«æ”¹å–„ã€‚
 *    - ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: difficulty, card set, basePairs, drag, pointer events, document listener
 *
 * 6. 2025-06-19: ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã§ã®ã‚¿ãƒƒãƒ—æ“ä½œã®ä¿®æ­£
 *    - ã‚¿ãƒƒãƒ—ã¨ãƒ‰ãƒ©ãƒƒã‚°ã‚’åŒºåˆ¥ã™ã‚‹ãŸã‚ã®é–¾å€¤ï¼ˆéŠã³ï¼‰ã‚’å°å…¥ã€‚
 *    - æŒ‡ã®ç§»å‹•è·é›¢ãŒã‚ãšã‹ãªå ´åˆã¯ã‚¿ãƒƒãƒ—ã€ä¸€å®šè·é›¢ã‚’è¶…ãˆãŸã‚‰ãƒ‰ãƒ©ãƒƒã‚°ã¨ã—ã¦èªè­˜ã™ã‚‹ã‚ˆã†ã«ä¿®æ­£ã€‚
 *    - ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: touch, tap, drag threshold, pointer events, mobile usability
 *
 * 7. 2025-06-19: ãƒ¬ãƒ™ãƒ«çŠ¶æ…‹ã®æ°¸ç¶šåŒ–
 *    - ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ç¾åœ¨ã®ãƒ¬ãƒ™ãƒ«ã‚’ä¿å­˜ã™ã‚‹æ©Ÿèƒ½ã‚’è¿½åŠ ã€‚
 *    - ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ã‚‚ã€æœ€å¾Œã«ãƒ—ãƒ¬ã‚¤ã—ã¦ã„ãŸãƒ¬ãƒ™ãƒ«ã‹ã‚‰å†é–‹ã§ãã‚‹ã‚ˆã†ã«ä¿®æ­£ã€‚
 *    - ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: cookie, persistent state, setCookie, getCookie, currentLevel
 */
(function() {
    'use strict';

    // --- ã“ã“ã‹ã‚‰æ”¹é€ ã§è¿½åŠ ã—ãŸã‚³ãƒ¼ãƒ‰ ---

    /**
     * æŒ‡å®šã•ã‚ŒãŸåå‰ã¨å€¤ã§ã‚¯ãƒƒã‚­ãƒ¼ã‚’è¨­å®šã™ã‚‹ã€‚
     * @param {string} name ã‚¯ãƒƒã‚­ãƒ¼ã®åå‰
     * @param {string|number} value ã‚¯ãƒƒã‚­ãƒ¼ã®å€¤
     * @param {number} days æœ‰åŠ¹æœŸé™ï¼ˆæ—¥æ•°ï¼‰
     */
    function setCookie(name, value, days) {
        let expires = "";
        if (days) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = "; expires=" + date.toUTCString();
        }
        // SameSite=Lax ã‚’æŒ‡å®šã—ã¦ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’è€ƒæ…®
        document.cookie = name + "=" + (value || "") + expires + "; path=/; SameSite=Lax";
    }

    /**
     * æŒ‡å®šã•ã‚ŒãŸåå‰ã®ã‚¯ãƒƒã‚­ãƒ¼ã®å€¤ã‚’å–å¾—ã™ã‚‹ã€‚
     * @param {string} name å–å¾—ã™ã‚‹ã‚¯ãƒƒã‚­ãƒ¼ã®åå‰
     * @returns {string|null} ã‚¯ãƒƒã‚­ãƒ¼ã®å€¤ã€‚å­˜åœ¨ã—ãªã„å ´åˆã¯nullã‚’è¿”ã™ã€‚
     */
    function getCookie(name) {
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for(let i = 0; i < ca.length; i++) {
            let c = ca[i];
            // å…ˆé ­ã®ç©ºç™½ã‚’å‰Šé™¤
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) {
                return c.substring(nameEQ.length, c.length);
            }
        }
        return null;
    }

    // --- ã“ã“ã¾ã§æ”¹é€ ã§è¿½åŠ ã—ãŸã‚³ãƒ¼ãƒ‰ ---

    const gameManager = { currentLevel: 1, gameState: {} };

    class XorShift32 {
      /**
       * ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
       * @param {number} seed åˆæœŸã‚·ãƒ¼ãƒ‰ï¼ˆ32bitæ•´æ•°, 0 ã‚’é¿ã‘ã‚‹ï¼‰
       */
      constructor(seed) {
        // 0 ã ã¨å…¨ãƒ“ãƒƒãƒˆ 0 ã®ã¾ã¾ã«ãªã£ã¦ã—ã¾ã†ã®ã§ã€ã‚‚ã— 0 ãŒæ¸¡ã•ã‚ŒãŸã‚‰é©å½“ãªå€¤ã‚’ä»£å…¥
        this.state = (seed >>> 0) || 0xDEADBEEF;
      }

      /**
       * æ¬¡ã®ä¹±æ•°ã‚’ç”Ÿæˆã—ã¦è¿”ã™
       * @returns {number} 32bit ã®ç¬¦å·ãªã—æ•´æ•° (0 â€¦ 0xFFFFFFFF)
       */
      nextUInt32() {
        // xorshift32 ã®ã‚³ã‚¢ (Marsaglia ã®ã‚ªãƒªã‚¸ãƒŠãƒ«)
        let x = this.state;
        x ^= x << 13;
        x ^= x >>> 17;
        x ^= x << 5;
        // 32bit ã«åˆ‡ã‚Šè©°ã‚ã¦è² ã®å€¤ãŒå‡ºãªã„ã‚ˆã†ã«ã™ã‚‹
        this.state = x >>> 0;
        return this.state;
      }

      /**
       * ä¹±æ•°ã‚’ 0ï½1 æœªæº€ã®æµ®å‹•å°æ•°ç‚¹ã§è¿”ã™
       * @returns {number} [0, 1)
       */
      random() {
        // 2^32 ã§å‰²ã£ã¦ [0,1) ã®ç¯„å›²ã«æ­£è¦åŒ–
        return this.nextUInt32() / 0x100000000;
      }
    }
    const XorShift = new XorShift32(12345 & 0xFFFFFFFF);


    function makeInteractive(containerId) {
        const container = document.getElementById(containerId);
        const board = container.querySelector('div');
        if (!board) return;

        let scale = 1, minScale = 0.2, maxScale = 3;
        let x = 0, y = 0;
        let pointerCache = [];
        let prevDiff = -1;
        let isDragging = false;
        let dragStartTarget = null;
        
        const DRAG_THRESHOLD = 5;
        let startX = 0, startY = 0;
        
        const handlePointerDown = (ev) => {
            if (!container.contains(ev.target)) return;
            pointerCache.push(ev);
            if (pointerCache.length === 1) {
                isDragging = false;
                dragStartTarget = ev.target;
                startX = ev.clientX;
                startY = ev.clientY;
            }
            document.addEventListener('pointermove', handlePointerMove);
            document.addEventListener('pointerup', handlePointerUp);
            document.addEventListener('pointercancel', handlePointerUp);
        };

        const handlePointerMove = (ev) => {
            const index = pointerCache.findIndex(cachedEv => cachedEv.pointerId === ev.pointerId);
            if (index > -1) {
                pointerCache[index] = ev;
            } else {
                return;
            }

            if (pointerCache.length === 1) {
                if (!isDragging) {
                    const dx = ev.clientX - startX;
                    const dy = ev.clientY - startY;
                    if (Math.sqrt(dx * dx + dy * dy) > DRAG_THRESHOLD) {
                        isDragging = true;
                    }
                }
                
                if (isDragging) {
                    x += ev.movementX;
                    y += ev.movementY;
                    board.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
                }
                ev.preventDefault();

            } else if (pointerCache.length === 2) {
                isDragging = true;
                const p1 = pointerCache[0], p2 = pointerCache[1];
                const curDiff = Math.sqrt(Math.pow(p1.clientX - p2.clientX, 2) + Math.pow(p1.clientY - p2.clientY, 2));
                const midPoint = { x: (p1.clientX + p2.clientX) / 2, y: (p1.clientY + p2.clientY) / 2 };

                if (prevDiff > 0) {
                    const scaleChange = curDiff / prevDiff;
                    const newScale = Math.max(minScale, Math.min(scale * scaleChange, maxScale));
                    x = midPoint.x - (midPoint.x - x) * (newScale / scale);
                    y = midPoint.y - (midPoint.y - y) * (newScale / scale);
                    scale = newScale;
                }
                prevDiff = curDiff;
                board.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
                ev.preventDefault();
            }
        };

        const handlePointerUp = (ev) => {
            if (!isDragging && dragStartTarget && dragStartTarget.classList.contains('card')) {
                if (pointerCache.length > 0 && ev.pointerId === pointerCache.find(p => p.pointerId === ev.pointerId)?.pointerId) {
                   const cardId = parseInt(dragStartTarget.id.split('-').pop());
                   onCardClick(cardId);
                }
            }
            pointerCache = pointerCache.filter(p => p.pointerId !== ev.pointerId);
            if (pointerCache.length < 2) {
                prevDiff = -1;
            }
            if (pointerCache.length === 0) {
                document.removeEventListener('pointermove', handlePointerMove);
                document.removeEventListener('pointerup', handlePointerUp);
                document.removeEventListener('pointercancel', handlePointerUp);
                dragStartTarget = null;
                isDragging = false;
            }
        };

        container.addEventListener('pointerdown', handlePointerDown);
        board.addEventListener('dragstart', (e) => e.preventDefault());
        container.addEventListener('wheel', (ev) => {
            ev.preventDefault();
            const scaleChange = ev.deltaY * -0.001;
            const newScale = Math.max(minScale, Math.min(scale * (1 + scaleChange), maxScale));
            x = ev.clientX - (ev.clientX - x) * (newScale / scale);
            y = ev.clientY - (ev.clientY - y) * (newScale / scale);
            scale = newScale;
            board.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
        });
    }

    function setBoardSizeAndPosition(cards, boardId) {
        const boardEl = document.getElementById(boardId);
        if (!cards || cards.length === 0 || !boardEl) return;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        cards.forEach(card => { minX = Math.min(minX, card.coords.x); maxX = Math.max(maxX, card.coords.x + 2); minY = Math.min(minY, card.coords.y); maxY = Math.max(maxY, card.coords.y + 2); });
        const cardWidth = 60;
        const cardHeight = 84;
        const boardPixelWidth = (maxX - minX) / 2 * cardWidth;
        const boardPixelHeight = (maxY - minY) / 2 * cardHeight;
        boardEl.style.width = `${boardPixelWidth}px`;
        boardEl.style.height = `${boardPixelHeight}px`;

        boardEl.querySelectorAll('.card').forEach(cardEl => {
            const cardId = parseInt(cardEl.id.split('-').pop());
            const cardData = cards.find(c => c.id === cardId);
            if (cardData) {
                const left = (cardData.coords.x - minX) / 2 * cardWidth;
                const top = (cardData.coords.y - minY) / 2 * cardHeight;
                cardEl.style.left = `${left}px`;
                cardEl.style.top = `${top}px`;
            }
        });

        const container = boardEl.parentElement;
        const containerRect = container.getBoundingClientRect();
        boardEl.style.left = `${(containerRect.width - boardPixelWidth)/2}px`;
        boardEl.style.top = `${(containerRect.height - boardPixelHeight)/2}px`;
        boardEl.style.transform = `translate(0, 0) scale(1)`;
    }

    function showStartScreen() {
        document.getElementById('start-screen').classList.remove('hidden');
        document.getElementById('game-view').classList.add('hidden');
        renderFractalBackground();
    }

    function renderFractalBackground() {
        const baseShape = generateCellularAutomataShape(20, 15);
        const proceduralLayout = generateProceduralLayout(baseShape);
        const { cards } = generateStructuralLayout(proceduralLayout);
        const requiredPairs = cards.length / 2;

        const basePairs = [
            ...Array.from({length: 4}, (_, i) => [{type: 'card', rank: i + 1, suit: 'heart', color: 'red'}, {type: 'card', rank: i + 1, suit: 'diamond', color: 'red'}]),
            ...Array.from({length: 4}, (_, i) => [{type: 'card', rank: i + 1, suit: 'spade', color: 'black'}, {type: 'card', rank: i + 1, suit: 'club', color: 'black'}]),
            [{type: 'joker', rank: 0, suit: 'joker', color: 'black'}, {type: 'joker', rank: 0, suit: 'joker', color: 'red'}]
        ];
        const content = {
            basePairs: basePairs,
            sets: Math.ceil(requiredPairs / basePairs.length)
        };

        const logicalPairs = generateContentSet(content, requiredPairs);
        if(!logicalPairs) return;
        const solveProcedure = createDummySolveProcedure(cards);
        assignCardsContent(cards, solveProcedure, logicalPairs);
        const display = {
            renderer: (card) => {
                const RANKS = { 0: 'ğŸ¤¡', 1: 'A', 11: 'J', 12: 'Q', 13: 'K' };
                const SUITS = { spade: 'â™ ', heart: 'â™¥', diamond: 'â™¦', club: 'â™£', joker: 'ğŸŒ›' };
                const rank = RANKS[card.rank] || (card.rank > 0 && card.rank < 11 ? card.rank : '');
                const suit = SUITS[card.suit];
                return rank || suit ? `${rank}<br>${suit}` : '';
            }
        };
        renderBoard(cards, display, 'start-background-board');
        setBoardSizeAndPosition(cards, 'start-background-board');
    }

    // --- `startGame` é–¢æ•°ã‚’æ”¹é€  ---
    function startGame(level) {
        // æ”¹é€ ç‚¹: ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ç¾åœ¨ã®ãƒ¬ãƒ™ãƒ«ã‚’ã‚¯ãƒƒã‚­ãƒ¼ã«ä¿å­˜ã™ã‚‹
        setCookie('currentLevel', level, 365); // 1å¹´é–“æœ‰åŠ¹ãªã‚¯ãƒƒã‚­ãƒ¼ã¨ã—ã¦ä¿å­˜

        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-view').classList.remove('hidden');
        const baseSize = 5 + level;
        const baseShape = generateCellularAutomataShape(baseSize, baseSize);
        const proceduralLayout = generateProceduralLayout(baseShape);
        const { cards, boardMap } = generateStructuralLayout(proceduralLayout);
        if(cards.length < 10) {
            startGame(level);
            return;
        }
        const requiredPairs = cards.length / 2;
        
        const basePairs = [
            ...Array.from({length: 4}, (_, i) => [{type: 'card', rank: i + 1, suit: 'heart', color: 'red'}, {type: 'card', rank: i + 1, suit: 'diamond', color: 'red'}]),
            ...Array.from({length: 4}, (_, i) => [{type: 'card', rank: i + 1, suit: 'spade', color: 'black'}, {type: 'card', rank: i + 1, suit: 'club', color: 'black'}]),
            [{type: 'joker', rank: 0, suit: 'joker', color: 'black'}, {type: 'joker', rank: 0, suit: 'joker', color: 'red'}]
        ];
        const requiredSets = Math.ceil(requiredPairs / basePairs.length);
        const config = {
            title: `ãƒ¬ãƒ™ãƒ« ${level}`,
            initialData: { cards, boardMap },
            content: {
                sets: requiredSets,
                basePairs: basePairs
            },
            display: {
                renderer: (card) => {
                    const RANKS = { 0: 'ğŸ¤¡', 1: 'A', 11: 'J', 12: 'Q', 13: 'K' };
                    const SUITS = { spade: 'â™ ', heart: 'â™¥', diamond: 'â™¦', club: 'â™£', joker: 'ğŸŒ›' };
                    const rank = RANKS[card.rank] || (card.rank > 0 && card.rank < 11 ? card.rank : '');
                    const suit = SUITS[card.suit];
                    return rank || suit ? `${rank}<br>${suit}` : '';
                }
            }
        };
        main(config);
    }

    // --- `DOMContentLoaded` ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’æ”¹é€  ---
    document.addEventListener('DOMContentLoaded', () => {
        // æ”¹é€ ç‚¹: ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ã‚¯ãƒƒã‚­ãƒ¼ã‹ã‚‰ãƒ¬ãƒ™ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        const savedLevel = getCookie('currentLevel');
        if (savedLevel) {
            // ã‚¯ãƒƒã‚­ãƒ¼ã«ä¿å­˜ã•ã‚ŒãŸãƒ¬ãƒ™ãƒ«ãŒã‚ã‚Œã°ã€gameManagerã«è¨­å®šã™ã‚‹
            const level = parseInt(savedLevel, 10);
            if (!isNaN(level) && level > 0) {
                gameManager.currentLevel = level;
            }
        }

        makeInteractive('start-background-container');
        makeInteractive('game-container');
        showStartScreen();
        document.getElementById('start-button').addEventListener('click', () => startGame(gameManager.currentLevel));
    });

    function main(config) {
        document.getElementById('game-title').textContent = config.title;
        setupGame(config);
    }

    function setupGame(config) {
        const { cards, boardMap } = config.initialData;
        gameManager.gameState = { cards, boardMap, selectedCards: [], gameStatus: 'playing', pairsLeft: cards.length / 2 };
        const solveProcedure = createSolveProcedure(boardMap, cards);
        if (!solveProcedure) {
            console.error("ã‚¯ãƒªã‚¢æ‰‹é †ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒªãƒˆãƒ©ã‚¤ã—ã¾ã™ã€‚");
            startGame(gameManager.currentLevel);
            return;
        }
        const logicalPairs = generateContentSet(config.content, gameManager.gameState.pairsLeft);
        if (!logicalPairs) {
            console.error("ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ãƒšã‚¢æ•°ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚");
            return;
        }
        assignCardsContent(cards, solveProcedure, logicalPairs);
        renderBoard(cards, config.display, 'game-board');
        setBoardSizeAndPosition(cards, 'game-board');
        updateSelectableStatus();
        updateMessage("ãƒšã‚¢ã‚’è¦‹ã¤ã‘ã¦ãã ã•ã„");
    }

    function renderBoard(cards, displayConfig, targetElementId) {
        const { renderer } = displayConfig;
        const boardEl = document.getElementById(targetElementId);
        if (!boardEl) return;
        boardEl.innerHTML = '';
        cards.forEach(card => {
            const cardEl = document.createElement('div');
            cardEl.id = `${targetElementId}-card-${card.id}`;
            cardEl.className = 'card';
            cardEl.innerHTML = renderer(card);
            if (card.color) cardEl.dataset.color = card.color;
            cardEl.style.zIndex = card.coords.z * 1000 + card.coords.y * 10;
            boardEl.appendChild(cardEl);
        });
    }

    function onCardClick(cardId) {
        if (gameManager.gameState.gameStatus !== 'playing') return;
        const clickedCard = gameManager.gameState.cards.find(c => c.id === cardId);
        if (!clickedCard || !clickedCard.isSelectable) return;
        const selectedIndex = gameManager.gameState.selectedCards.findIndex(c => c.id === cardId);
        if (selectedIndex > -1) {
            gameManager.gameState.selectedCards.splice(selectedIndex, 1);
            document.querySelector(`#game-board-card-${cardId}`).classList.remove('selected');
        } else {
            gameManager.gameState.selectedCards.push(clickedCard);
            document.querySelector(`#game-board-card-${cardId}`).classList.add('selected');
        }
        if (gameManager.gameState.selectedCards.length === 2) {
            if (isPair(gameManager.gameState.selectedCards[0], gameManager.gameState.selectedCards[1])) {
                removePair(gameManager.gameState.selectedCards);
                updateSelectableStatus();
                checkGameEnd();
            } else {
                updateMessage("ãƒšã‚¢ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼");
                setTimeout(() => { if (gameManager.gameState.gameStatus === 'playing') updateMessage("ãƒšã‚¢ã‚’è¦‹ã¤ã‘ã¦ãã ã•ã„"); }, 1500);
            }
            gameManager.gameState.selectedCards.forEach(c => document.querySelector(`#game-board-card-${c.id}`)?.classList.remove('selected'));
            gameManager.gameState.selectedCards = [];
        }
    }
    
    function createSolveProcedure(initialBoardMap, initialCards) {
        const MAX_ATTEMPTS = 10;
        const isSelectableInSimulation = (card, boardMap) => {
            if (card.isRemoved) return false;
            const { x, y, z } = card.coords;
            const maxZ = boardMap.length - 1;
            if (z < maxZ) {
                const upperLayer = boardMap[z + 1];
                for (let dy = 0; dy < 2; dy++) {
                    for (let dx = 0; dx < 2; dx++) {
                        if (upperLayer[y + dy] && upperLayer[y + dy][x + dx] !== null) {
                            return false;
                        }
                    }
                }
            }
            const currentLayer = boardMap[z];
            const boardWidth = currentLayer[0].length;
            const isLeftOpen = (x === 0) || (currentLayer[y][x - 1] === null && currentLayer[y + 1][x - 1] === null);
            const isRightOpen = (x + 2 >= boardWidth) || (currentLayer[y][x + 2] === null && currentLayer[y + 1][x + 2] === null);
            return isLeftOpen || isRightOpen;
        };
        for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
            let tempBoardMap = JSON.parse(JSON.stringify(initialBoardMap));
            let tempCards = JSON.parse(JSON.stringify(initialCards));
            const procedure = [];
            let remainingCards = tempCards.length;
            let possible = true;
            while (remainingCards > 0) {
                const selectableCards = tempCards.filter(card => !card.isRemoved && isSelectableInSimulation(card, tempBoardMap));
                if (selectableCards.length < 2) {
                    possible = false;
                    break;
                }
                for (let i = selectableCards.length - 1; i > 0; i--) {
                    const j = Math.floor(XorShift.random() * (i + 1));
                    [selectableCards[i], selectableCards[j]] = [selectableCards[j], selectableCards[i]];
                }
                const pair = [selectableCards[0], selectableCards[1]];
                procedure.push([pair[0].id, pair[1].id]);
                for (const card of pair) {
                    const cardInSim = tempCards.find(c => c.id === card.id);
                    cardInSim.isRemoved = true;
                    const { x, y, z } = card.coords;
                    for (let dy = 0; dy < 2; dy++) {
                        for (let dx = 0; dx < 2; dx++) {
                            tempBoardMap[z][y + dy][x + dx] = null;
                        }
                    }
                }
                remainingCards -= 2;
            }
            if (possible && remainingCards === 0) {
                return procedure.reverse();
            }
        }
        console.error("ã‚¯ãƒªã‚¢æ‰‹é †ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆæœ€å¤§è©¦è¡Œå›æ•°è¶…éï¼‰");
        return null;
    }
    
    function createDummySolveProcedure(cards) {
        const shuffledIds = cards.map(c => c.id).sort(() => 0.5 - XorShift.random());
        const procedure = [];
        for (let i = 0; i < shuffledIds.length; i += 2) {
            if (shuffledIds[i+1]) procedure.push([shuffledIds[i], shuffledIds[i+1]]);
        }
        return procedure;
    }
    
    function generateCellularAutomataShape(width, height, generations = 4, birthThreshold = 5, survivalThreshold = 4) {
        let grid = Array.from({length: height}, () => Array(width).fill(false));
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (XorShift.random() < 0.45) grid[y][x] = true;
            }
        }
        for (let i = 0; i < generations; i++) {
            const newGrid = Array.from({length: height}, () => Array(width).fill(false));
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let neighbours = 0;
                    for (let ny = -1; ny <= 1; ny++) {
                        for (let nx = -1; nx <= 1; nx++) {
                            if (ny === 0 && nx === 0) continue;
                            const checkX = x + nx;
                            const checkY = y + ny;
                            if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height && grid[checkY][checkX]) {
                                neighbours++;
                            }
                        }
                    }
                    if (grid[y][x]) {
                        if (neighbours >= survivalThreshold) newGrid[y][x] = true;
                    } else {
                        if (neighbours >= birthThreshold) newGrid[y][x] = true;
                    }
                }
            }
            grid = newGrid;
        }
        return grid;
    }

    function checkGameEnd() {
        if (gameManager.gameState.pairsLeft === 0) {
            gameManager.gameState.gameStatus = 'cleared';
            updateMessage(`ãƒ¬ãƒ™ãƒ« ${gameManager.currentLevel} ã‚¯ãƒªã‚¢ï¼`);
            setTimeout(() => {
                gameManager.currentLevel++;
                startGame(gameManager.currentLevel);
            }, 3000);
            return;
        }
        const selectableCards = gameManager.gameState.cards.filter(c => c.isSelectable);
        const possiblePairs = new Map();
        let foundPair = false;
        for (const card of selectableCards) {
            const key = card.type === 'joker' ? 'joker' : (card.char ? card.char : `${card.color}-${card.rank}`);
            if (possiblePairs.has(key)) {
                foundPair = true;
                break;
            }
            possiblePairs.set(key, true);
        }
        if (!foundPair) {
            gameManager.gameState.gameStatus = 'stuck';
            updateMessage("æ‰‹è©°ã¾ã‚Šã§ã™...");
        } else {
            updateMessage(`${gameManager.gameState.pairsLeft} ãƒšã‚¢æ®‹ã‚Š`);
        }
    }

    function generateProceduralLayout(baseShape) {
        const fullLayoutDef = [baseShape];
        let currentLayerDef = baseShape;
        while (true) {
            const nextLayerDef = [];
            let hasCardInNextLayer = false;
            const prevHeight = currentLayerDef.length;
            const prevWidth = prevHeight > 0 ? currentLayerDef[0].length : 0;
            for (let y = 0; y < prevHeight - 1; y++) {
                nextLayerDef[y] = [];
                for (let x = 0; x < prevWidth - 1; x++) {
                    const canPlace = currentLayerDef[y][x] && currentLayerDef[y][x+1] && currentLayerDef[y+1][x] && currentLayerDef[y+1][x+1];
                    nextLayerDef[y][x] = canPlace;
                    if (canPlace) hasCardInNextLayer = true;
                }
            }
            if (!hasCardInNextLayer) break;
            fullLayoutDef.push(nextLayerDef);
            currentLayerDef = nextLayerDef;
        }
        return fullLayoutDef;
    }

    function generateStructuralLayout(layoutDef) {
        const cards = [];
        let cardId = 1;
        const baseLayer = layoutDef[0] || [];
        const baseHeight = baseLayer.length;
        const baseWidth = baseHeight > 0 ? baseLayer[0].length : 0;
        const maxLayers = layoutDef.length;
        const totalGridWidth = baseWidth * 2 + maxLayers - 1;
        const totalGridHeight = baseHeight * 2 + maxLayers - 1;
        const boardMap = Array.from({ length: maxLayers }, () => Array.from({ length: totalGridHeight }, () => Array(totalGridWidth).fill(null)));
        layoutDef.forEach((layer, z) => {
            layer.forEach((row, y) => {
                row.forEach((hasCard, x) => {
                    if (hasCard) {
                        const gridX = x * 2 + z;
                        const gridY = y * 2 + z;
                        const newCard = { id: cardId++, coords: { x: gridX, y: gridY, z }, isRemoved: false, isSelectable: false };
                        cards.push(newCard);
                        for (let dy = 0; dy < 2; dy++) {
                            for (let dx = 0; dx < 2; dx++) {
                                boardMap[z][gridY + dy][gridX + dx] = newCard.id;
                            }
                        }
                    }
                });
            });
        });
        if (cards.length % 2 !== 0) {
            const cardToRemove = cards.pop();
            const {x, y, z} = cardToRemove.coords;
            for (let dy = 0; dy < 2; dy++) {
                for (let dx = 0; dx < 2; dx++) {
                    boardMap[z][y + dy][x + dx] = null;
                }
            }
        }
        return { cards, boardMap };
    }
    
    function generateContentSet(contentConfig, requiredPairs) {
        const { basePairs, sets } = contentConfig;
        const allPairs = [];
        for (let i = 0; i < sets; i++) {
            allPairs.push(...JSON.parse(JSON.stringify(basePairs)));
        }
        if (allPairs.length < requiredPairs) {
            return null;
        }
        for (let i = allPairs.length - 1; i > 0; i--) {
            const j = Math.floor(XorShift.random() * (i + 1));
            [allPairs[i], allPairs[j]] = [allPairs[j], allPairs[i]];
        }
        return allPairs.slice(0, requiredPairs);
    }

    function assignCardsContent(cards, solveProcedure, logicalPairs) {
        for (const idPair of solveProcedure) {
            const logicalPair = logicalPairs.pop();
            if (!logicalPair) {
                console.error("è«–ç†ãƒšã‚¢ã®æ•°ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚");
                break;
            }
            const card1 = cards.find(c => c.id === idPair[0]);
            const card2 = cards.find(c => c.id === idPair[1]);
            if(card1 && card2) {
                Object.assign(card1, logicalPair[0]);
                Object.assign(card2, logicalPair[1]);
            } else {
                console.error("IDã«å¯¾å¿œã™ã‚‹ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:", idPair);
            }
        }
    }

    function isPair(card1, card2) {
        if (!card1 || !card2) return false;
        if (card1.type === 'joker' && card2.type === 'joker') return true;
        if (card1.color === card2.color && card1.rank === card2.rank) return true;
        if(card1.char && card1.char === card2.char) return true;
        return false;
    }

    function updateSelectableStatus() {
        gameManager.gameState.cards.forEach(card => {
            if (card.isRemoved) return;
            const wasSelectable = card.isSelectable;
            card.isSelectable = isCardSelectable(card, gameManager.gameState.boardMap);
            const cardEl = document.getElementById(`game-board-card-${card.id}`);
            if(cardEl){
                if (card.isSelectable && !wasSelectable) {
                    cardEl.classList.add('selectable');
                } else if (!card.isSelectable && wasSelectable) {
                    cardEl.classList.remove('selectable');
                }
            }
        });
    }

    function isCardSelectable(card, boardMap) {
        if (card.isRemoved) return false;
        const { x, y, z } = card.coords;
        const currentLayer = boardMap[z];
        const upperLayer = boardMap[z + 1];
        if (upperLayer) {
            for (let dy = 0; dy < 2; dy++) {
                for (let dx = 0; dx < 2; dx++) {
                    const checkY = y + dy;
                    const checkX = x + dx;
                    if (upperLayer[checkY] && upperLayer[checkY][checkX] !== null) {
                        return false;
                    }
                }
            }
        }
        const isLeftOpen = (x < 1) || (currentLayer[y][x - 1] === null && currentLayer[y + 1][x - 1] === null);
        const isRightOpen = (x + 2 >= currentLayer[0].length) || (currentLayer[y][x + 2] === null && currentLayer[y + 1][x + 2] === null);
        return isLeftOpen || isRightOpen;
    }
    
    function updateMessage(text) {
        document.getElementById('message-area').textContent = text;
    }

    function removePair(cards) {
        for (const card of cards) {
            card.isRemoved = true;
            const cardEl = document.getElementById(`game-board-card-${card.id}`);
            cardEl.classList.add('removed');
            cardEl.classList.remove('selectable', 'selected');
            for (let dy = 0; dy < 2; dy++) {
                for (let dx = 0; dx < 2; dx++) {
                    const finalY = Math.floor(card.coords.y + dy);
                    const finalX = Math.floor(card.coords.x + dx);
                    if (gameManager.gameState.boardMap[card.coords.z] && gameManager.gameState.boardMap[card.coords.z][finalY]) {
                        gameManager.gameState.boardMap[card.coords.z][finalY][finalX] = null;
                    }
                }
            }
        }
        gameManager.gameState.pairsLeft--;
    }
})();
</script>
</body>
</html>
